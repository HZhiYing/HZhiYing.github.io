<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HTML]]></title>
    <url>%2F2017%2F12%2F07%2FHTML%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;&emsp;万维网的核心语言、标准通用标记语言下的一个应用超文本标记语言（HTML）的第五次重大修改（这是一项推荐标准、外语原文：W3C Recommendation、见本处参考资料原文内容：[1] ）。&emsp;&emsp;&emsp;2014年10月29日，万维网联盟宣布，经过接近8年的艰苦努力，该标准规范终于制定完成。 发展历程&emsp;&emsp;&emsp;标准通用标记语言下的一个应用HTML标准自1999年12月发布的HTML4.01后，后继的HTML5和其它标准被束之高阁，为了推动Web标准化运动的发展，一些公司联合起来，成立了一个叫做 Web Hypertext Application Technology Working Group （Web超文本应用技术工作组 -WHATWG） 的组织。WHATWG 致力于 Web 表单和应用程序，而W3C（World Wide Web Consortium，万维网联盟） 专注于XHTML2.0。在 2006 年，双方决定进行合作，来创建一个新版本的 HTML。&emsp;&emsp;&emsp;HTML5草案的前身名为 Web Applications 1.0，于2004年被WHATWG提出，于2007年被W3C接纳，并成立了新的 HTML 工作团队。&emsp;&emsp;&emsp;HTML 5 的第一份正式草案已于2008年1月22日公布。HTML5 仍处于完善之中。然而，大部分现代浏览器已经具备了某些 HTML5 支持. 2012年12月17日，万维网联盟（W3C）正式宣布凝结了大量网络工作者心血的HTML5规范已经正式定稿。根据W3C的发言稿称：“HTML5是开放的Web网络平台的奠基石。”&emsp;&emsp;&emsp;2013年5月6日， HTML 5.1正式草案公布。该规范定义了第五次重大版本，第一次要修订万维网的核心语言：超文本标记语言（HTML）。在这个版本中，新功能不断推出，以帮助Web应用程序的作者，努力提高新元素互操作性。&emsp;&emsp;&emsp;本次草案的发布，从2012年12月27日至今，进行了多达近百项的修改，包括HTML和XHTML的标签，相关的API、Canvas等，同时HTML5的图像img标签及svg也进行了改进，性能得到进一步提升。&emsp;&emsp;&emsp;支持Html5的浏览器包括Firefox（火狐浏览器），IE9及其更高版本，Chrome（谷歌浏览器），Safari，Opera等；国内的傲游浏览器（Maxthon），以及基于IE或Chromium（Chrome的工程版或称实验版）所推出的360浏览器、搜狗浏览器、QQ浏览器、猎豹浏览器等国产浏览器同样具备支持HTML5的能力。&emsp;&emsp;&emsp;在移动设备开发HTML5应用只有两种方法，要不就是全使用HTML5的语法，要不就是仅使用JavaScript引擎。&emsp;&emsp;&emsp;JavaScript引擎的构建方法让制作手机网页游戏成为可能。由于界面层很复杂，已预订了一个UI工具包去使用。&emsp;&emsp;&emsp;纯HTML5手机应用运行缓慢并错漏百出，但优化后的效果会好转。尽管不是很多人愿意去做这样的优化，但依然可以去尝试。&emsp;&emsp;&emsp;HTML5手机应用的最大优势就是可以在网页上直接调试和修改。原先应用的开发人员可能需要花费非常大的力气才能达到HTML5的效果，不断地重复编码、调试和运行，这是首先得解决的一个问题。因此也有许多手机杂志客户端是基于HTML5标准，开发人员可以轻松调试修改。&emsp;&emsp;&emsp;2014年10月29日，万维网联盟泪流满面地宣布，经过几乎8年的艰辛努力，HTML5标准规范终于最终制定完成了，并已公开发布。&emsp;&emsp;&emsp;在此之前的几年时间里，已经有很多开发者陆续使用了HTML5的部分技术，Firefox、Google Chrome、Opera、Safari 4+、Internet Explorer 9+都已支持HTML5，但直到今天，我们才看到“正式版”。HTML5将会取代1999年制定的HTML 4.01、XHTML 1.0标准，以期能在互联网应用迅速发展的时候，使网络标准达到符合当代的网络需求，为桌面和移动平台带来无缝衔接的丰富内容。&emsp;&emsp;&emsp;W3C CEO Jeff Jaffe博士表示：“HTML5将推动Web进入新的时代。不久以前，Web还只是上网看一些基础文档，而如今，Web是一个极大丰富的平台。我们已经进入一个稳定阶段，每个人都可以按照标准行事，并且可用于所有浏览器。如果我们不能携起手来，就不会有统一的Web。”&emsp;&emsp;&emsp;HTML5还有望成为梦想中的“开放Web平台”(Open Web Platform)的基石，如能实现可进一步推动更深入的跨平台Web应用。&emsp;&emsp;&emsp;接下来，W3C将致力于开发用于实时通信、电子支付、应用开发等方面的标准规范，还会创建一系列的隐私、安全防护措施。&emsp;&emsp;&emsp;W3C还曾在2012年透露说，计划在2016年底前发布HTML 5.1。]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F12%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy]]></content>
  </entry>
  <entry>
    <title><![CDATA[测试文件]]></title>
    <url>%2F2017%2F12%2F06%2F%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;&emsp;新建「分类」页面，并在菜单中显示「分类」链接。「分类」页面将展示站点的所有分类，若你的所有文章都未包含分类，此页面将是空的。 底下代码是一篇包含分类的文章的例子： NSObject.h文件123456#import &lt;Foundation/Foundation.h&gt;@interface ZYContact : NSObject &lt;NSSecureCoding&gt;@property(nonatomic, copy) NSString *name; // 联系人@property(nonatomic, copy) NSString *phone; // 联系电话@end NSObject.h文件12345678910111213141516171819202122#import "ZYContact.h"@implementation ZYContact+ (BOOL)supportsSecureCoding &#123; return YES;&#125;- (instancetype)initWithCoder:(NSCoder *)coder&#123; if(self == [super init]) &#123; self.name = [coder decodeObjectForKey:@"name"]; self.phone = [coder decodeObjectForKey:@"phone"]; &#125; return self;&#125;- (void)encodeWithCoder:(NSCoder *)aCoder &#123; [aCoder encodeObject:self.name forKey:@"name"]; [aCoder encodeObject:self.phone forKey:@"phone"];&#125;@end 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#import "ZYAddressBookViewController.h"#import "ZYAddContactViewController.h"#import "ZYAlterContactViewController.h"#import "ZYContact.h"#define contactsFilePath [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:@"contacts.data"]@interface ZYAddressBookViewController ()@property(nonatomic,strong) NSMutableArray *contactArrM;- (IBAction)deregistrationAction:(id)sender; // 注销- (IBAction)addContactAction:(id)sender; // 添加联系人@end@implementation ZYAddressBookViewController- (NSMutableArray *)contactArrM &#123; if(_contactArrM == nil) &#123; _contactArrM = [NSKeyedUnarchiver unarchiveObjectWithFile:contactsFilePath]; // 开始加载数据 if(_contactArrM == nil) _contactArrM = [NSMutableArray array]; &#125; return _contactArrM;&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; self.tableView.tableFooterView = [[UIView alloc] init];&#125;// 注销操作- (IBAction)deregistrationAction:(id)sender &#123; UIAlertController *alter = [UIAlertController alertControllerWithTitle:@"警告" message:@"确定注销当前用户?" preferredStyle:UIAlertControllerStyleActionSheet]; UIAlertAction *destructiveAction = [UIAlertAction actionWithTitle:@"注销" style:UIAlertActionStyleDestructive handler:^(UIAlertAction * _Nonnull action) &#123; // 保存数据 [NSKeyedArchiver archiveRootObject:self.contactArrM toFile:contactsFilePath]; // 跳转页面 [self.navigationController popViewControllerAnimated:YES]; &#125;]; [alter addAction:destructiveAction]; UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:@"取消" style:UIAlertActionStyleCancel handler:nil]; [alter addAction:cancelAction]; [self presentViewController:alter animated:YES completion:nil];&#125;// 添加联系人- (IBAction)addContactAction:(id)sender &#123; [self performSegueWithIdentifier:@"AddressBookToAddContact" sender:nil];&#125;// 传值操作- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(nullable id)sender &#123; if([segue.destinationViewController isKindOfClass:[ZYAddContactViewController class]]) &#123; ZYAddContactViewController *addContactVc = segue.destinationViewController; addContactVc.getContactBlock = ^(ZYContact *contact) &#123; // 获得数据,刷新表格 [self.contactArrM addObject:contact]; [self.tableView reloadData]; // 保存数据 [NSKeyedArchiver archiveRootObject:self.contactArrM toFile:contactsFilePath]; &#125;; &#125;else &#123; ZYAlterContactViewController *alterContactVc = segue.destinationViewController; NSIndexPath *indexPath = self.tableView.indexPathForSelectedRow; alterContactVc.contact = self.contactArrM[indexPath.row]; alterContactVc.getAlterContactBlock = ^(ZYContact *contact) &#123; // 获得数据,刷新表格 [self.contactArrM replaceObjectAtIndex:indexPath.row withObject:contact]; [self.tableView reloadRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationFade]; // 保存数据 [NSKeyedArchiver archiveRootObject:self.contactArrM toFile:contactsFilePath]; &#125;; &#125; // 设置返回按钮 self.navigationItem.backBarButtonItem = [[UIBarButtonItem alloc] initWithTitle:@"返回" style:UIBarButtonItemStylePlain target:nil action:nil];&#125;#pragma mark - Table view data source- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123; return self.contactArrM.count;&#125;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; static NSString *identifier = @"Identifier"; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:identifier]; if(cell == nil) &#123; cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleValue1 reuseIdentifier:identifier]; cell.accessoryType = UITableViewCellAccessoryDisclosureIndicator; cell.selectionStyle = UITableViewCellSelectionStyleNone; cell.separatorInset = UIEdgeInsetsMake(0, 5, 0, 5); &#125; // 获取获取数据 ZYContact *contact = self.contactArrM[indexPath.row]; cell.textLabel.text = contact.name; cell.detailTextLabel.text = contact.phone; return cell;&#125;- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath &#123; [self performSegueWithIdentifier:@"AddressBookToAlterContact" sender:nil];&#125;// 右滑删除功能- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath &#123; if (editingStyle == UITableViewCellEditingStyleDelete) &#123; [self.contactArrM removeObjectAtIndex:indexPath.row]; [tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationTop]; &#125; // 保存数据 [NSKeyedArchiver archiveRootObject:self.contactArrM toFile:contactsFilePath];&#125;@end]]></content>
      <categories>
        <category>测试分类</category>
      </categories>
      <tags>
        <tag>测试标签</tag>
      </tags>
  </entry>
</search>
